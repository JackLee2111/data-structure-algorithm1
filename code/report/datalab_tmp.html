<!DOCTYPE html>
<html>
<head>
<title>datalab.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="datalab%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A">datalab实验报告</h1>
<h6 id="%E6%9D%8E%E4%BF%8A%E9%9C%96-2021201709">李俊霖 2021201709</h6>
<h3 id="%E9%97%AE%E9%A2%981-bitxor">问题1 bitXor</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>用位运算表示异或<code>^</code>.</p>
<h4 id="%E6%80%9D%E8%B7%AF%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B">思路&amp;优化过程</h4>
<p>采用离散数学的主析取范式和主合取范式的思想。
刚开始使用主析取范式展开，得到解决方式1，需花费8个符号:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitXor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span>
</span>{
    <span class="hljs-keyword">return</span> ~((~(x &amp; (~y))) &amp; (~(y &amp; (~x))));
}
</div></code></pre>
<p>采用主合取范式展开，优化到7个符号:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitXor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span>
</span>{
    <span class="hljs-keyword">return</span> ~(x &amp; y) &amp; ~(~y &amp; ~x);
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%982-thirdbits">问题2 thirdBits</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>构造类似于<code>……001001001001</code>的二进制串</p>
<h4 id="%E6%80%9D%E8%B7%AF%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B">思路&amp;优化过程</h4>
<h5 id="%E5%88%9D%E5%A7%8B%E6%80%9D%E8%B7%AF">初始思路</h5>
<p>构造出0x09，即<code>00001001</code>，然后按照位数依次左移6、12、24个位得到目标：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">thirdBits</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
  <span class="hljs-keyword">int</span> x = <span class="hljs-number">0x09</span>;
  x = x + (x &lt;&lt; <span class="hljs-number">6</span>);
  x = x + (x &lt;&lt; <span class="hljs-number">12</span>);
  x = x + (x &lt;&lt; <span class="hljs-number">24</span>);
  <span class="hljs-keyword">return</span> x;
}
</div></code></pre>
<h5 id="%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF">优化思路</h5>
<p>先构造出0x49，即<code>01001001</code>,然后向左移动两次9个和18个位即可拼接成所需二进制串:</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">thirdBits</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0x49</span>;
    x = x + (x &lt;&lt; <span class="hljs-number">9</span>);
    x = x + (x &lt;&lt; <span class="hljs-number">18</span>);
    <span class="hljs-keyword">return</span> x;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%983-fitsshort">问题3 fitsShort</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>判断一个<code>int</code>数是否可以表示成16位的有符号整数。（是否超出16位有符号整数的范围）</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>若这个数为正数（右移补0），<code>x&gt;&gt;15</code>取出这个数16-32位，<code>x&gt;&gt;31</code>可以取出这个数的符号位0（<code>000...000</code>)，如果没超过16位的范围，符号位和16-32应该同为0。</li>
<li>若这个数为负数（右移补1），<code>x&gt;&gt;15</code>取出这个数16-32位，<code>x&gt;&gt;31</code>可以取出这个数的符号位1（<code>111...111</code>)，如果没超过16位的范围，符号位和16-32应该同为1。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsShort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">return</span> !((x &gt;&gt; <span class="hljs-number">15</span>) ^ (x &gt;&gt; <span class="hljs-number">31</span>));
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%984-istmax">问题4 isTmax</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>判断是不是最大的二进制int整数，即<code>01111111...1</code></p>
<h4 id="%E6%80%9D%E8%B7%AF%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B">思路&amp;优化过程</h4>
<h5 id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-6%E6%AD%A5">基本思路 （6步）</h5>
<p>最大int整数+1得到<code>100000...000</code>，与其本身相加会得到<code>111111...111</code>。但值得注意的是<code>-1</code>，即<code>11111...111</code>也会有此性质，需要把这种情况排除，方法是判断这个数＋1取反是否为0。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isTmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
  <span class="hljs-keyword">int</span> m = x + <span class="hljs-number">1</span>;
  x = ~(m + x) + (!m);

  <span class="hljs-keyword">return</span> !x;
}
</div></code></pre>
<h5 id="%E4%BC%98%E5%8C%965%E6%AD%A5">优化（5步）</h5>
<p>最大int整数+1得到<code>100000...000</code>，这个数加自己相加会得到<code>000000...000</code>，用这种方法可以节省一个符号。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isTmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> m = x + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> !((m + m) | (!m));
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%985-fitsbits">问题5 fitsBits</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>判断一个<code>int</code>数是否可以表示成<code>n</code>位的有符号整数。（是否超出<code>n</code>位有符号整数的范围）</p>
<h5 id="%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF">基本思路</h5>
<p>思路和问题三基本相同，问题在于构造出<code>n-1</code>。</p>
<ul>
<li>版本1 用<code>n + (~1 + 1)</code>代表<code>n - 1</code>。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
  <span class="hljs-keyword">int</span> i = n + (~<span class="hljs-number">1</span> + <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> !((x &gt;&gt; i) ^ (x &gt;&gt; <span class="hljs-number">31</span>));
}
</div></code></pre>
<ul>
<li>优化版本1.0 用<code>n + (~1)</code>代表<code>n - 1</code>。</li>
<li>优化版本2.0 用<code>n + 31</code>代表<code>n - 1</code>。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-comment">// int i = n + (~0); //~0 means -1，6步</span>
    <span class="hljs-keyword">int</span> i = n + <span class="hljs-number">31</span>; <span class="hljs-comment">// means j减1， 5步</span>
    <span class="hljs-keyword">return</span> !((x &gt;&gt; i) ^ (x &gt;&gt; <span class="hljs-number">31</span>));
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%986-upperbits">问题6 upperBits</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>设置一个数的前<code>n</code>位为1。</p>
<h4 id="%E6%80%9D%E8%B7%AF%E5%92%8C%E4%BC%98%E5%8C%96">思路和优化</h4>
<ul>
<li>开始想用long long，发现不行。</li>
<li>注意判别输入0的情况，不输出任何1。</li>
<li>用<code>!!(n)</code>来判断输入是否为0，然后移到最左，再相对应右移<code>n-1</code>位。</li>
<li><code>n-1</code>有多种写法
<ul>
<li>1.0版<code>n + (~1 + 1)</code></li>
<li>2.0版<code>n + (~1)</code></li>
<li>3.0版<code>n + 31</code>
代码如下：</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upperBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">int</span> a = !!(n);
    <span class="hljs-keyword">int</span> b = a &lt;&lt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">int</span> ans = b &gt;&gt; (n + <span class="hljs-number">31</span>);
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%987-anyoddbit">问题7 anyOddBit</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>判断是否有任何奇数位的数字为1。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<p>构造掩码 <code>m = 10101010...10101010</code>,即<code>AAAAAAAA</code>，然后掩码与数字与运算即可判断。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">anyOddBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> m = <span class="hljs-number">0xAA</span> + (<span class="hljs-number">0xAA</span> &lt;&lt; <span class="hljs-number">8</span>);
    m = m + (m &lt;&lt; <span class="hljs-number">16</span>);
    <span class="hljs-keyword">return</span> !!(m &amp; x);
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%988-byteswap">问题8 byteSwap</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>交换第n个和第m个字节。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>实现交换，想到用异或的思想。</li>
<li>异或交换原理
<ul>
<li>与自身异或为0；</li>
<li>与0异或还是自身；</li>
<li>具有交换律；</li>
<li>具有结合律。</li>
</ul>
</li>
<li>首先，将字节扩展到位。每个byte代表8个bit，左移3位即乘8。</li>
<li>x右移相应的位数得到的末8位要交换的那个字节。</li>
<li>异或交换，保留后八位。</li>
<li>再把bits1分别移到需要交换的两个字节处
<ul>
<li>对于每一个字节，异或两次为0，异或一次为自身。</li>
<li>与原数异或之后，该位置的字节异或了两次，另一个字节异或了一次，因此留的是另一个字节，实现交换。</li>
</ul>
</li>
</ul>
<p>代码如下：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">byteSwap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> m)</span>
</span>{
    <span class="hljs-comment">//将字节扩展到位</span>
    <span class="hljs-keyword">int</span> n_bit = n &lt;&lt; <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> m_bit = m &lt;&lt; <span class="hljs-number">3</span>;

    <span class="hljs-comment">//异或交换</span>
    <span class="hljs-keyword">int</span> bits1 = ((x &gt;&gt; n_bit) ^ (x &gt;&gt; m_bit));
    <span class="hljs-comment">//保留后八位（1个字节）</span>
    bits1 = bits1 &amp; <span class="hljs-number">0xFF</span>;

    <span class="hljs-comment">//再把bits1分别移到需要交换的两个字节处</span>
    <span class="hljs-keyword">int</span> ans = x ^ (bits1 &lt;&lt; n_bit) ^ (bits1 &lt;&lt; m_bit);
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%989-absval">问题9 absVal</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>输出给定数字的绝对值</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<h5 id="%E6%80%9D%E8%B7%AF1">思路1</h5>
<ul>
<li>关键在于怎么实现选择的结构，&gt;0不变，&lt;0取反</li>
<li><code>x &gt;&gt; 31</code>取出符号位（全0或全1）</li>
<li>如果为1，负数，则取反+1（<code>(~x) + 1</code>）</li>
<li>如果为0，正数，不变。</li>
<li>若x为负数，<code>x &gt;&gt; 31</code>为0xFFFFFFFF，<code>(x &gt;&gt; 31)^x</code>可以把取反；若x为正数，<code>x &gt;&gt; 31</code>为0，<code>(x &gt;&gt; 31)^x</code>操作后x不变。</li>
<li><code>num &amp; a</code>是一个调整的构造，在x&gt;0时为0，x&lt;0时为1。
代码如下：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">absVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> num = x &gt;&gt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0x1</span>;
    <span class="hljs-keyword">return</span> (num ^ x) + (num &amp; a); <span class="hljs-comment">// 4步</span>
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9810-divpwr2">问题10 divpwr2</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>一个数除以2的指数，向0取整。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>正数右移n为即得到结果。</li>
<li>负数右移n位结果不同，因为取整规则不同，所以我们要构造一个偏移值。</li>
<li>找规律得到偏移值。-5/2^2 =-1.25-&gt;-1,正确；-6/2^2 =-1.5-&gt;-2,应该为-1;-7/2^2 =-1.75-&gt;-2,但也应该为-1.我们整体给一个＋3的偏移值之后，他的值四舍五入之后就等于向0取整的值了。</li>
<li>所以偏移值为2^n-1。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">int</span> s = x &gt;&gt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">int</span> b = (<span class="hljs-number">1</span> &lt;&lt; n) + ~<span class="hljs-number">0</span>;
    x = x + (b &amp; s);
    <span class="hljs-keyword">return</span> x &gt;&gt; n;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9811-floatneg">问题11 float_neg</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>如果是NAN，返回参数；否则返回-f。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>NAN：如果指数位区域全位1，且小数位不为0，这个数表示为不是一个数。形如<code>0111 1111 1....</code>。</li>
<li>让这个数与<code>0111 1111 1..111</code>做与运算，如果前面重合且后23位不为零，则满足NAN情况。</li>
<li>计算-f直接把最高位取反即可（异或1取反）。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span>
</span>{
    <span class="hljs-keyword">if</span> ((uf &amp; <span class="hljs-number">0x7FFFFFFF</span>) &gt; <span class="hljs-number">0x7F800000</span>)
        <span class="hljs-keyword">return</span> uf;
    <span class="hljs-keyword">return</span> (uf ^ <span class="hljs-number">0x80000000</span>);
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9812-logicalneg">问题12 logicalNeg</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>用位运算实现逻辑非<code>!</code>。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>非0返回0，0返回1</li>
<li>利用特性：任何数取反＋1，最高位一定和本身相反；但0取反1，还是0。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalNeg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> ans = (~x + <span class="hljs-number">1</span>) | x;
    ans = ans &gt;&gt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">return</span> ans + <span class="hljs-number">1</span>;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9813-bitmask">问题13 bitMask</h3>
<h4 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h4>
<p>构造中间几位为1的掩码，如<code>00000111100000</code>。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>分别构造两个高位为0和低位为0的掩码，两个与运算得到目标掩码。</li>
<li>用<code>0xFFFFFFFF</code>来得到两个高位为0和低位为0的掩码。</li>
<li>低位为0的掩码直接左移相应位数。</li>
<li>高位为0的掩码在高位往前一位＋1，直接把高位的1全部进1变成0。</li>
<li>在构造高位0掩码时，不能直接<code>a &lt;&lt; (highbit + 1)</code>，否则当<code>highbit</code>为<code>31</code>时，这是个未定义行为。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitMask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> highbit, <span class="hljs-keyword">int</span> lowbit)</span>
</span>{
    <span class="hljs-keyword">int</span> x = ~<span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0x1</span>;
    <span class="hljs-keyword">int</span> low = x &lt;&lt; lowbit;
    <span class="hljs-keyword">int</span> hi = x + (a &lt;&lt; highbit &lt;&lt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> low &amp; hi;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9814-isgreater">问题14 isGreater</h3>
<h4 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h4>
<p>如果x&gt;y，返回1；否则返回0。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>通过<code>x &gt;&gt; 31</code>和<code>y &gt;&gt; 31</code>分别获取x、y的符号位。</li>
<li>符号位不等的情况下，只需判断：若x负y正，返回0,；其余返回1</li>
<li>符号位相等的情况下，需要判断大小。
<ul>
<li>注意只有x&gt;y，才返回1，即x&gt;=y+1,才返回1。</li>
<li>注意到，-y = ~y + 1,因此~y + x = x - y - 1,如果x - y - 1 &gt;= 0,即x&gt;=y-1,即x&gt;y,返回1，其余返回0。</li>
<li>因此可以直接用<code>(~y + x) &gt;&gt; 31</code>来判断。</li>
</ul>
</li>
<li>符号位相等和不等种情况用或（|）来连接。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isGreater</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span>
</span>{
    <span class="hljs-comment">//获取x、y的符号位</span>
    <span class="hljs-keyword">int</span> sign_x = x &gt;&gt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">int</span> sign_y = y &gt;&gt; <span class="hljs-number">31</span>;

    <span class="hljs-comment">//符号位不等</span>
    <span class="hljs-keyword">int</span> sign_not_equal = sign_x &amp; !sign_y;

    <span class="hljs-comment">//符号位相等的情况下，判断大小</span>
    <span class="hljs-comment">//其中-y = ~y + 1,因此~y + x = x - y - 1,如果x - y - 1 &gt;= 0,即x&gt;=y-1,即x&gt;y,返回1，其余返回0.</span>
    <span class="hljs-keyword">int</span> sign_equal = (!(sign_x ^ sign_y)) &amp; ((~y + x) &gt;&gt; <span class="hljs-number">31</span>);
    <span class="hljs-keyword">return</span> !(sign_equal | sign_not_equal);
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9815-logicalshift">问题15 logicalShift</h3>
<h4 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h4>
<p>向右移动n位，前面补0.</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>向右移动，与一个高n位为0、其他位1的掩码进行与运算，消掉高位可能出现的1</li>
<li>重点在于怎么构造形如<code>0...0011...11</code>的掩码。</li>
<li>构造1：<code>m = (~0) + (1 &lt;&lt; (~n) &lt;&lt; 1)</code>,类似bitmask题目。(7步)</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">int</span> ans = x &gt;&gt; n;
    <span class="hljs-keyword">int</span> m = (~<span class="hljs-number">0</span>) + (<span class="hljs-number">1</span> &lt;&lt; (~n) &lt;&lt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> ans &amp; m;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9816-satmul2">问题16 satMul2</h3>
<h4 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h4>
<p>计算一个数×2，如果溢出输出最大/最小值。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>正常情况下，左移一位即为×2。</li>
<li>如果溢出，即最高位符号位和次高位不相同，左移之后符号位取反，用<code>bit_2 = ans &gt;&gt; 31</code>取出次高位。</li>
<li>用异或<code>x ^ ans</code>可以得到最高位和次高位是否相同，作为分支的依据。</li>
<li>如果相同，notflow。</li>
<li>如果不相同，溢出，则需要考虑溢出的最大还是最小。
<ul>
<li>如果次高位为1（bit_2为111……），最高位0，则正数溢出，应该输出01111……</li>
<li>如果次高位为0（bit_2为000……），最高位1，则负数溢出，应该输出10000……</li>
<li>归纳可知，可以用bit_2和10000……异或实现对输出的控制。
代码：</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">satMul2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> ans = x &lt;&lt; <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> bit_2 = ans &gt;&gt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">int</span> same = (x ^ ans) &gt;&gt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">int</span> notflow = (~same) &amp; ans;
    <span class="hljs-keyword">int</span> t = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;
    <span class="hljs-keyword">int</span> isflow = (same) &amp; (t ^ bit_2);
    <span class="hljs-keyword">return</span> notflow + isflow;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9817-subok">问题17 subOK</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>判断两数相减会不会超出<code>int</code>表示范围。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li><code>x-y</code>用 <code>x + (~y + 1)</code> 来表示。</li>
<li>溢出只有x为正y为负，x为负y为正两种情况，即xy异号，用<code>x^y</code>来判断。</li>
<li>若溢出，结果和x是异号的，同样用异或判断。</li>
<li>因此如果x和y异号和x和result异号，则溢出。</li>
<li>返回0或1，用！来调整。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subOK</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span>
</span>{
  <span class="hljs-keyword">int</span> result = x + (~y + <span class="hljs-number">1</span>);
  <span class="hljs-keyword">int</span> num = (x ^ result) &amp; (x ^ y);
  <span class="hljs-keyword">int</span> ans = num &gt;&gt; <span class="hljs-number">31</span>;
  <span class="hljs-keyword">return</span> !ans;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9818-truethreefourths">问题18 trueThreeFourths</h3>
<h4 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h4>
<p>求一个数×3/4的值，向0舍入。</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>关键在于怎么区分正负数和处理负数时向上取整的问题。</p>
<ul>
<li>整数部分：
<ul>
<li>除以4，再将结果乘3即可。</li>
</ul>
</li>
<li>小数部分：
<ul>
<li>对于正数，获取除以4的余数（0,1,2,3），乘三再除以4取整即可判断是否需要舍入。</li>
<li>对于负数，获取除以4的余数，还要加上3才可以向上取整。
<ul>
<li>加3小技巧：<code>sgn = (x &gt;&gt; 31) &amp; 3</code>，顺便可以判断正负号。
代码如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">trueThreeFourths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-comment">//除以4</span>
    <span class="hljs-keyword">int</span> x1 = x &gt;&gt; <span class="hljs-number">2</span>;
    <span class="hljs-comment">// x2获取除以4的余数 0,1,2,3</span>
    <span class="hljs-keyword">int</span> x2 = x &amp; <span class="hljs-number">3</span>;
    <span class="hljs-comment">//乘以4</span>
    <span class="hljs-keyword">int</span> integer = (x1 + x1 + x1);
    <span class="hljs-comment">// 向零取整，意味着&gt;=0时向下取整，&lt;0时向上取整，即在/4前+3</span>
    <span class="hljs-comment">// 正数不动（本来就是向下取整），负数加3，再整体除以4</span>
    <span class="hljs-keyword">int</span> sgn = (x &gt;&gt; <span class="hljs-number">31</span>) &amp; <span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span>  fraction = (x2 + x2 + x2 + sgn) &gt;&gt; <span class="hljs-number">2</span>;
    <span class="hljs-keyword">return</span> integer + fraction;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9819-ispower2">问题19 isPower2</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>判断一个数是不是2的倍数。特别的，负数和零都不是2的倍数。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<ul>
<li>2的倍数具有的性质：第n位为1，其余位都为0。这个数-1会得到0~n-1位为1，其余位为0的数，在和数字本身与运算会把所有的1都消掉，变成全0。</li>
<li>然而x=0也具有上述性质，因此需要排除。</li>
<li>凡是负数，即最高位为1的数，都排除。</li>
<li>因此，首先构造<code>flag = ~(x &gt;&gt; 31)</code>再和<code>(!!x)</code>做与运算，排除负数和0的情况。</li>
<li><code>ans = ~(x &amp; (x + (~0)))</code>即为判断2的倍数的性质。</li>
<li><code>ans</code>和<code>flag</code>做与运算可以得到结果。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPower2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> 
</span>{
    <span class="hljs-keyword">int</span> flag = ~(x &gt;&gt; <span class="hljs-number">31</span>);
    flag = flag &amp; (!!x);
    <span class="hljs-keyword">int</span> ans = !(x &amp; (x + (~<span class="hljs-number">0</span>)));
    <span class="hljs-keyword">return</span> ans &amp; flag;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9820-floati2f">问题20 float_i2f</h3>
<h4 id="%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0">题目描述</h4>
<p>将一个int类型整数转成float的浮点数形式。</p>
<h4 id="%E6%80%9D%E8%B7%AF">思路</h4>
<p>按照浮点数的表示基本规则，分为三段（符号位、阶码、尾数）</p>
<ul>
<li>首先，对0进行特判。</li>
<li>把负数变为正数方便后续处理。</li>
<li>符号位：用<code>sign = x &amp; 0x80000000</code>获取符号位。</li>
<li>阶码位
<ul>
<li>找到除最高位之外的第一个1，times是这个1的从左往右数的第几个</li>
<li>阶码：127+32-times</li>
<li>这个数左移23放到浮点数的阶码位置。</li>
</ul>
</li>
<li>尾数：
<ul>
<li>原数右移9位，放到尾数位置。</li>
<li>考虑尾数数字右移9位之后的舍入问题
<ul>
<li>如果后9位大于1 0000 0000，要进一位</li>
<li>如果后10位是11 0000 0000，也要进一位</li>
<li>其他情况不进位</li>
</ul>
</li>
</ul>
</li>
<li>把三段相加拼接即可。
完整代码：</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{

    <span class="hljs-keyword">unsigned</span> sign = x &amp; <span class="hljs-number">0x80000000</span>;
    <span class="hljs-keyword">unsigned</span> ans = x;
    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-comment">//如果是负数，变为正数</span>
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)
    {
        ans = -x;
    }
    <span class="hljs-keyword">unsigned</span> times = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">unsigned</span> mask = <span class="hljs-number">0x80000000</span>;
    <span class="hljs-keyword">unsigned</span> t;
    <span class="hljs-comment">//找到除最高位之外的第一个1，times是这个1的从左往右数的第几个</span>
    <span class="hljs-comment">//得到的ans是1之后的小数位的数字</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        t = ans;
        ans = ans &lt;&lt; <span class="hljs-number">1</span>;
        times++;
        <span class="hljs-keyword">if</span> (t &amp; mask)
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">//下面考虑尾数数字右移9位之后的舍入问题</span>
    <span class="hljs-keyword">unsigned</span> flag;
    <span class="hljs-comment">//如果后9位大于1 0000 0000，要进一位</span>
    <span class="hljs-keyword">if</span> ((ans &amp; <span class="hljs-number">0x01FF</span>) &gt; <span class="hljs-number">0x0100</span>)
        flag = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//如果后10位是11 0000 0000，也要进一位</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((ans &amp; <span class="hljs-number">0x03FF</span>) == <span class="hljs-number">0x0300</span>)
        flag = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//其他情况不进位</span>
    <span class="hljs-keyword">else</span>
        flag = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//把三段拼接起来（尾数：原数右移9位；阶码：127+32-times）</span>
    <span class="hljs-keyword">int</span> anss = sign + (ans &gt;&gt; <span class="hljs-number">9</span>) + ((<span class="hljs-number">159</span> - times) &lt;&lt; <span class="hljs-number">23</span>) + flag;
    <span class="hljs-keyword">return</span> anss;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9821-howmanybits">问题21 howManyBits</h3>
<h4 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h4>
<p>判断x需要多少位的补码表示。</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<ul>
<li>用异或的思想，即<code>check = x ^ (x &lt;&lt; 1)</code>可以得到从低到高位最后一个有意义的1（或者说是最后一个1）。</li>
<li>下面转化为如何找到<code>check</code>里这个最高位的1在哪个位置，采用二分查找的思想。</li>
<li>对<code>check</code>右移16位，查看其17~32位是否为零。如果不为零，则代表最高位在16~32位中，将<code>check</code>再右移十六位，下一步是查看在17~32位中的哪一位；如果不为零，则代表最高位在1~16位中，将<code>check</code>不再右移，下一步是查看在1~16位中的哪一位。</li>
<li>下面右移8位，将check分成1-8位和9-16位查找，重复上述思路。</li>
<li>右移4位，将check分成1-4位和5-8位查找，重复上述思路。</li>
<li>以此类推，直到将check分成1位和2位。</li>
<li>最后的答案应该＋1，因为无论是任何数都至少有1位（即使是0）。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">howManyBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>
</span>{
    <span class="hljs-keyword">int</span> check = x ^ (x &lt;&lt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">int</span> bit_16_to_32 = !!(check &gt;&gt; <span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-number">4</span>;
    check &gt;&gt;= bit_16_to_32;
    <span class="hljs-keyword">int</span> bit_8_to_16 = !!(check &gt;&gt; <span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-number">3</span>;
    check &gt;&gt;= bit_8_to_16;
    <span class="hljs-keyword">int</span> bit_4_to_8 = !!(check &gt;&gt; <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">2</span>;
    check &gt;&gt;= bit_4_to_8;
    <span class="hljs-keyword">int</span> bit_2_to_4 = !!(check &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1</span>;
    check &gt;&gt;= bit_2_to_4;
    <span class="hljs-keyword">int</span> bit_1_to_2 = !!(check &gt;&gt; <span class="hljs-number">1</span>);
    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span> + bit_16_to_32 + bit_8_to_16 + bit_4_to_8 + bit_2_to_4 + bit_1_to_2;
    <span class="hljs-keyword">return</span> ans;
}
</div></code></pre>
<h3 id="%E9%97%AE%E9%A2%9822-floathalf">问题22 float_half</h3>
<h4 id="%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">问题描述</h4>
<p>输出0.5*一个浮点数的值，如果输入的是NAN则返回原值。</p>
<h4 id="%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF">解决思路</h4>
<p>对于规范化浮点数，乘0.5即为阶码-1；对于非规范化浮点数，乘0.5即为尾数右移一位，并考虑舍入问题。</p>
<ul>
<li>首先用<code>uf &amp; 0x80000000</code>获取符号位。</li>
<li>特判NAN：如果阶码的八位全为1，则直接返回原值。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> ((uf &amp; <span class="hljs-number">0x7FFFFFFF</span>) &gt;= <span class="hljs-number">0x7F800000</span>)
        <span class="hljs-keyword">return</span> uf;
</div></code></pre>
<ul>
<li>用<code>e = uf &amp; 0x7F800000</code>获取八位阶码。</li>
<li>如果阶码&gt;1，直接减掉阶码部分的1即可。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (e &gt; <span class="hljs-number">0x00800000</span>)
        <span class="hljs-keyword">return</span> (uf - <span class="hljs-number">0x00800000</span>);
</div></code></pre>
<ul>
<li>
<p>如果阶码&lt;=1，需要尾数部分整体右移一位，注意需要先<code>int shift = uf ^ sign</code>把符号位踢掉。</p>
</li>
<li>
<p>考虑舍入问题，右移一位只需要考虑最后两位：如果后两位为10，或00，直接右移舍去；如果为01，向偶数舍入，也是直接右移舍去；如果为11，向偶数舍入需要进一位，所以先＋1，再舍去。判断语句：<code>(uf &amp; 0x3) == 0x3</code>。</p>
</li>
<li>
<p>后来发现更好的特判NAN办法：在获取阶码之后，直接比对阶码是否全为1：</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> (e == <span class="hljs-number">0x7F800000</span>)
        <span class="hljs-keyword">return</span> uf;
</div></code></pre>
<p>最终代码：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_half</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> sign = uf &amp; <span class="hljs-number">0x80000000</span>;
    <span class="hljs-keyword">unsigned</span> e = uf &amp; <span class="hljs-number">0x7F800000</span>;
    <span class="hljs-keyword">if</span> (e == <span class="hljs-number">0x7F800000</span>)
        <span class="hljs-keyword">return</span> uf;
    <span class="hljs-keyword">if</span> (e &gt; <span class="hljs-number">0x00800000</span>)
        <span class="hljs-keyword">return</span> (uf - <span class="hljs-number">0x00800000</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">0x00800000</span>)
    {
        <span class="hljs-keyword">int</span> shift = uf ^ sign;
        <span class="hljs-keyword">int</span> l = ((uf &amp; <span class="hljs-number">0x3</span>) == <span class="hljs-number">0x3</span>);
        <span class="hljs-keyword">return</span> (sign + ((shift + l) &gt;&gt; <span class="hljs-number">1</span>));
    }
}
</div></code></pre>
<h2 id="%E6%80%BB%E7%BB%93%E4%B8%8E%E4%BD%93%E4%BC%9A">总结与体会</h2>
<ul>
<li>
<p>位运算操作
相对于一般的高级语言运算，使用位运算需要我们对底层算法逻辑更加明晰。通过这次的 实验，我对位运算的操作、补码的表示、浮点数的表示有了更深入的了解和认识，也对他们之间的运算逻辑更为熟悉。</p>
</li>
<li>
<p>要关注边界条件和特殊值
datalab中的很多题，我在刚开始写的时候感觉思路很清晰，但总是无法通过。后来发现是很多边界条件我都没有考虑在内，导致边界的值输出不正确，比如0、全1、第32位等等。对边界的考虑的全面性在平时写代码中也是很关键的，可以提高代码的容错性和是程序的逻辑更清晰有效，通过这次实验，我也提高了写代码过程中的边界条件敏感性。</p>
</li>
</ul>
<p>非常感谢柴老师课上的耐心讲解，感谢助教在我完成本次实验中提供的帮助！</p>

</body>
</html>
